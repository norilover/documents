# Rust

1. [The Rust Programming Language](https://doc.rust-lang.org/book/title-page.html)
2. [Foreword](https://doc.rust-lang.org/book/foreword.html)
3. [Introduction](https://doc.rust-lang.org/book/ch00-00-introduction.html)
4. [**1.** Getting Started](https://doc.rust-lang.org/book/ch01-00-getting-started.html)
5. 1. [**1.1.** Installation](https://doc.rust-lang.org/book/ch01-01-installation.html)
   2. [**1.2.** Hello, World!](https://doc.rust-lang.org/book/ch01-02-hello-world.html)
   3. [**1.3.** Hello, Cargo!](https://doc.rust-lang.org/book/ch01-03-hello-cargo.html)
6. [**2.** Programming a Guessing Game](https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html)
7. [**3.** Common Programming Concepts](https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html)
8. 1. [**3.1.** Variables and Mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html)
   2. [**3.2.** Data Types](https://doc.rust-lang.org/book/ch03-02-data-types.html)
   3. [**3.3.** Functions](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html)
   4. [**3.4.** Comments](https://doc.rust-lang.org/book/ch03-04-comments.html)
   5. [**3.5.** Control Flow](https://doc.rust-lang.org/book/ch03-05-control-flow.html)
9. [**4.** Understanding Ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)
10. 1. [**4.1.** What is Ownership?](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)
    2. [**4.2.** References and Borrowing](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html)
    3. [**4.3.** The Slice Type](https://doc.rust-lang.org/book/ch04-03-slices.html)
11. [**5.** Using Structs to Structure Related Data](https://doc.rust-lang.org/book/ch05-00-structs.html)
12. 1. [**5.1.** Defining and Instantiating Structs](https://doc.rust-lang.org/book/ch05-01-defining-structs.html)
    2. [**5.2.** An Example Program Using Structs](https://doc.rust-lang.org/book/ch05-02-example-structs.html)
    3. [**5.3.** Method Syntax](https://doc.rust-lang.org/book/ch05-03-method-syntax.html)
13. [**6.** Enums and Pattern Matching](https://doc.rust-lang.org/book/ch06-00-enums.html)
14. 1. [**6.1.** Defining an Enum](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html)
    2. [**6.2.** The match Control Flow Operator](https://doc.rust-lang.org/book/ch06-02-match.html)
    3. [**6.3.** Concise Control Flow with if let](https://doc.rust-lang.org/book/ch06-03-if-let.html)
15. [**7.** Managing Growing Projects with Packages, Crates, and Modules](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)
16. 1. [**7.1.** Packages and Crates](https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html)
    2. [**7.2.** Defining Modules to Control Scope and Privacy](https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html)
    3. [**7.3.** Paths for Referring to an Item in the Module Tree](https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html)
    4. [**7.4.** Bringing Paths Into Scope with the use Keyword](https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html)
    5. [**7.5.** Separating Modules into Different Files](https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html)
17. [**8.** Common Collections](https://doc.rust-lang.org/book/ch08-00-common-collections.html)
18. 1. [**8.1.** Storing Lists of Values with Vectors](https://doc.rust-lang.org/book/ch08-01-vectors.html)
    2. [**8.2.** Storing UTF-8 Encoded Text with Strings](https://doc.rust-lang.org/book/ch08-02-strings.html)
    3. [**8.3.** Storing Keys with Associated Values in Hash Maps](https://doc.rust-lang.org/book/ch08-03-hash-maps.html)
19. [**9.** Error Handling](https://doc.rust-lang.org/book/ch09-00-error-handling.html)
20. 1. [**9.1.** Unrecoverable Errors with panic!](https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html)
    2. [**9.2.** Recoverable Errors with Result](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html)
    3. [**9.3.** To panic! or Not To panic!](https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html)
21. [**10.** Generic Types, Traits, and Lifetimes](https://doc.rust-lang.org/book/ch10-00-generics.html)
22. 1. [**10.1.** Generic Data Types](https://doc.rust-lang.org/book/ch10-01-syntax.html)
    2. [**10.2.** Traits: Defining Shared Behavior](https://doc.rust-lang.org/book/ch10-02-traits.html)
    3. [**10.3.** Validating References with Lifetimes](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html)
23. [**11.** Writing Automated Tests](https://doc.rust-lang.org/book/ch11-00-testing.html)
24. 1. [**11.1.** How to Write Tests](https://doc.rust-lang.org/book/ch11-01-writing-tests.html)
    2. [**11.2.** Controlling How Tests Are Run](https://doc.rust-lang.org/book/ch11-02-running-tests.html)
    3. [**11.3.** Test Organization](https://doc.rust-lang.org/book/ch11-03-test-organization.html)
25. [**12.** An I/O Project: Building a Command Line Program](https://doc.rust-lang.org/book/ch12-00-an-io-project.html)
26. 1. [**12.1.** Accepting Command Line Arguments](https://doc.rust-lang.org/book/ch12-01-accepting-command-line-arguments.html)
    2. [**12.2.** Reading a File](https://doc.rust-lang.org/book/ch12-02-reading-a-file.html)
    3. [**12.3.** Refactoring to Improve Modularity and Error Handling](https://doc.rust-lang.org/book/ch12-03-improving-error-handling-and-modularity.html)
    4. [**12.4.** Developing the Library’s Functionality with Test Driven Development](https://doc.rust-lang.org/book/ch12-04-testing-the-librarys-functionality.html)
    5. [**12.5.** Working with Environment Variables](https://doc.rust-lang.org/book/ch12-05-working-with-environment-variables.html)
    6. [**12.6.** Writing Error Messages to Standard Error Instead of Standard Output](https://doc.rust-lang.org/book/ch12-06-writing-to-stderr-instead-of-stdout.html)
27. [**13.** Functional Language Features: Iterators and Closures](https://doc.rust-lang.org/book/ch13-00-functional-features.html)
28. 1. [**13.1.** Closures: Anonymous Functions that Can Capture Their Environment](https://doc.rust-lang.org/book/ch13-01-closures.html)
    2. [**13.2.** Processing a Series of Items with Iterators](https://doc.rust-lang.org/book/ch13-02-iterators.html)
    3. [**13.3.** Improving Our I/O Project](https://doc.rust-lang.org/book/ch13-03-improving-our-io-project.html)
    4. [**13.4.** Comparing Performance: Loops vs. Iterators](https://doc.rust-lang.org/book/ch13-04-performance.html)
29. [**14.** More about Cargo and Crates.io](https://doc.rust-lang.org/book/ch14-00-more-about-cargo.html)
30. 1. [**14.1.** Customizing Builds with Release Profiles](https://doc.rust-lang.org/book/ch14-01-release-profiles.html)
    2. [**14.2.** Publishing a Crate to Crates.io](https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html)
    3. [**14.3.** Cargo Workspaces](https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html)
    4. [**14.4.** Installing Binaries from Crates.io with cargo install](https://doc.rust-lang.org/book/ch14-04-installing-binaries.html)
    5. [**14.5.** Extending Cargo with Custom Commands](https://doc.rust-lang.org/book/ch14-05-extending-cargo.html)
31. [**15.** Smart Pointers](https://doc.rust-lang.org/book/ch15-00-smart-pointers.html)
32. 1. [**15.1.** Using Box to Point to Data on the Heap](https://doc.rust-lang.org/book/ch15-01-box.html)
    2. [**15.2.** Treating Smart Pointers Like Regular References with the Deref Trait](https://doc.rust-lang.org/book/ch15-02-deref.html)
    3. [**15.3.** Running Code on Cleanup with the Drop Trait](https://doc.rust-lang.org/book/ch15-03-drop.html)
    4. [**15.4.** Rc, the Reference Counted Smart Pointer](https://doc.rust-lang.org/book/ch15-04-rc.html)
    5. [**15.5.** RefCell and the Interior Mutability Pattern](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html)
    6. [**15.6.** Reference Cycles Can Leak Memory](https://doc.rust-lang.org/book/ch15-06-reference-cycles.html)
33. [**16.** Fearless Concurrency](https://doc.rust-lang.org/book/ch16-00-concurrency.html)
34. 1. [**16.1.** Using Threads to Run Code Simultaneously](https://doc.rust-lang.org/book/ch16-01-threads.html)
    2. [**16.2.** Using Message Passing to Transfer Data Between Threads](https://doc.rust-lang.org/book/ch16-02-message-passing.html)
    3. [**16.3.** Shared-State Concurrency](https://doc.rust-lang.org/book/ch16-03-shared-state.html)
    4. [**16.4.** Extensible Concurrency with the Sync and Send Traits](https://doc.rust-lang.org/book/ch16-04-extensible-concurrency-sync-and-send.html)
35. [**17.** Object Oriented Programming Features of Rust](https://doc.rust-lang.org/book/ch17-00-oop.html)
36. 1. [**17.1.** Characteristics of Object-Oriented Languages](https://doc.rust-lang.org/book/ch17-01-what-is-oo.html)
    2. [**17.2.** Using Trait Objects That Allow for Values of Different Types](https://doc.rust-lang.org/book/ch17-02-trait-objects.html)
    3. [**17.3.** Implementing an Object-Oriented Design Pattern](https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html)
37. [**18.** Patterns and Matching](https://doc.rust-lang.org/book/ch18-00-patterns.html)
38. 1. [**18.1.** All the Places Patterns Can Be Used](https://doc.rust-lang.org/book/ch18-01-all-the-places-for-patterns.html)
    2. [**18.2.** Refutability: Whether a Pattern Might Fail to Match](https://doc.rust-lang.org/book/ch18-02-refutability.html)
    3. [**18.3.** Pattern Syntax](https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html)
39. [**19.** Advanced Features](https://doc.rust-lang.org/book/ch19-00-advanced-features.html)
40. 1. [**19.1.** Unsafe Rust](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)
    2. [**19.2.** Advanced Traits](https://doc.rust-lang.org/book/ch19-03-advanced-traits.html)
    3. [**19.3.** Advanced Types](https://doc.rust-lang.org/book/ch19-04-advanced-types.html)
    4. [**19.4.** Advanced Functions and Closures](https://doc.rust-lang.org/book/ch19-05-advanced-functions-and-closures.html)
    5. [**19.5.** Macros](https://doc.rust-lang.org/book/ch19-06-macros.html)
41. [**20.** Final Project: Building a Multithreaded Web Server](https://doc.rust-lang.org/book/ch20-00-final-project-a-web-server.html)
42. 1. [**20.1.** Building a Single-Threaded Web Server](https://doc.rust-lang.org/book/ch20-01-single-threaded.html)
    2. [**20.2.** Turning Our Single-Threaded Server into a Multithreaded Server](https://doc.rust-lang.org/book/ch20-02-multithreaded.html)
    3. [**20.3.** Graceful Shutdown and Cleanup](https://doc.rust-lang.org/book/ch20-03-graceful-shutdown-and-cleanup.html)
43. [**21.** Appendix](https://doc.rust-lang.org/book/appendix-00.html)
44. 1. [**21.1.** A - Keywords](https://doc.rust-lang.org/book/appendix-01-keywords.html)
    2. [**21.2.** B - Operators and Symbols](https://doc.rust-lang.org/book/appendix-02-operators.html)
    3. [**21.3.** C - Derivable Traits](https://doc.rust-lang.org/book/appendix-03-derivable-traits.html)
    4. [**21.4.** D - Useful Development Tools](https://doc.rust-lang.org/book/appendix-04-useful-development-tools.html)
    5. [**21.5.** E - Editions](https://doc.rust-lang.org/book/appendix-05-editions.html)
    6. [**21.6.** F - Translations of the Book](https://doc.rust-lang.org/book/appendix-06-translation.html)
    7. [**21.7.** G - How Rust is Made and “Nightly Rust”](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html)

# The Rust Programming Language

[ ](https://doc.rust-lang.org/book/print.html)

## [Appendix A: Keywords](https://doc.rust-lang.org/book/appendix-01-keywords.html#appendix-a-keywords)

The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers (except as raw identifiers as we’ll discuss in the “[Raw Identifiers](https://doc.rust-lang.org/book/appendix-01-keywords.html#raw-identifiers)” section), including names of functions, variables, parameters, struct fields, modules, crates, constants, macros, static values, attributes, types, traits, or lifetimes.

### [Keywords Currently in Use](https://doc.rust-lang.org/book/appendix-01-keywords.html#keywords-currently-in-use)

The following keywords currently have the functionality described.

- `as` - perform primitive casting, disambiguate the specific trait containing an item, or rename items in `use` and `extern crate` statements
- `async` - return a `Future` instead of blocking the current thread
- `await` - suspend execution until the result of a `Future` is ready
- `break` - exit a loop immediately
- `const` - define constant items or constant raw pointers
- `continue` - continue to the next loop iteration
- `crate` - link an external crate or a macro variable representing the crate in which the macro is defined
- `dyn` - dynamic dispatch to a trait object
- `else` - fallback for `if` and `if let` control flow constructs
- `enum` - define an enumeration
- `extern` - link an external crate, function, or variable
- `false` - Boolean false literal
- `fn` - define a function or the function pointer type
- `for` - loop over items from an iterator, implement a trait, or specify a higher-ranked lifetime
- `if` - branch based on the result of a conditional expression
- `impl` - implement inherent or trait functionality
- `in` - part of `for` loop syntax
- `let` - bind a variable
- `loop` - loop unconditionally
- `match` - match a value to patterns
- `mod` - define a module
- `move` - make a closure take ownership of all its captures
- `mut` - denote mutability in references, raw pointers, or pattern bindings
- `pub` - denote public visibility in struct fields, `impl` blocks, or modules
- `ref` - bind by reference
- `return` - return from function
- `Self` - a type alias for the type we are defining or implementing
- `self` - method subject or current module
- `static` - global variable or lifetime lasting the entire program execution
- `struct` - define a structure
- `super` - parent module of the current module
- `trait` - define a trait
- `true` - Boolean true literal
- `type` - define a type alias or associated type
- `union` - define a [union](https://doc.rust-lang.org/reference/items/unions.html) and is only a keyword when used in a union declaration
- `unsafe` - denote unsafe code, functions, traits, or implementations
- `use` - bring symbols into scope
- `where` - denote clauses that constrain a type
- `while` - loop conditionally based on the result of an expression

### [Keywords Reserved for Future Use](https://doc.rust-lang.org/book/appendix-01-keywords.html#keywords-reserved-for-future-use)

The following keywords do not have any functionality but are reserved by Rust for potential future use.

- `abstract`
- `become`
- `box`
- `do`
- `final`
- `macro`
- `override`
- `priv`
- `try`
- `typeof`
- `unsized`
- `virtual`
- `yield`

### [Raw Identifiers](https://doc.rust-lang.org/book/appendix-01-keywords.html#raw-identifiers)

*Raw identifiers* are the syntax that lets you use keywords where they wouldn’t normally be allowed. You use a raw identifier by prefixing a keyword with `r#`.

For example, `match` is a keyword. If you try to compile the following function that uses `match` as its name:

Filename: src/main.rs

```rust
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

you’ll get this error:

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

The error shows that you can’t use the keyword `match` as the function identifier. To use `match` as a function name, you need to use the raw identifier syntax, like this:

Filename: src/main.rs

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

This code will compile without any errors. Note the `r#` prefix on the function name in its definition as well as where the function is called in `main`.

Raw identifiers allow you to use any word you choose as an identifier, even if that word happens to be a reserved keyword. In addition, raw identifiers allow you to use libraries written in a different Rust edition than your crate uses. For example, `try` isn’t a keyword in the 2015 edition but is in the 2018 edition. If you depend on a library that’s written using the 2015 edition and has a `try` function, you’ll need to use the raw identifier syntax, `r#try` in this case, to call that function from your 2018 edition code. See [Appendix E](https://doc.rust-lang.org/book/appendix-05-editions.html) for more information on editions.







## [Appendix B: Operators and Symbols](https://doc.rust-lang.org/book/appendix-02-operators.html#appendix-b-operators-and-symbols)

This appendix contains a glossary of Rust’s syntax, including operators and other symbols that appear by themselves or in the context of paths, generics, trait bounds, macros, attributes, comments, tuples, and brackets.

### [Operators](https://doc.rust-lang.org/book/appendix-02-operators.html#operators)

Table B-1 contains the operators in Rust, an example of how the operator would appear in context, a short explanation, and whether that operator is overloadable. If an operator is overloadable, the relevant trait to use to overload that operator is listed.

Table B-1: Operators

| Operator | Example                                          | Explanation                              | Overloadable?  |
| -------- | ------------------------------------------------ | ---------------------------------------- | -------------- |
| `!`      | `ident!(...)`, `ident!{...}`, `ident![...]`      | Macro expansion                          |                |
| `!`      | `!expr`                                          | Bitwise or logical complement            | `Not`          |
| `!=`     | `var != expr`                                    | Nonequality comparison                   | `PartialEq`    |
| `%`      | `expr % expr`                                    | Arithmetic remainder                     | `Rem`          |
| `%=`     | `var %= expr`                                    | Arithmetic remainder and assignment      | `RemAssign`    |
| `&`      | `&expr`, `&mut expr`                             | Borrow                                   |                |
| `&`      | `&type`, `&mut type`, `&'a type`, `&'a mut type` | Borrowed pointer type                    |                |
| `&`      | `expr & expr`                                    | Bitwise AND                              | `BitAnd`       |
| `&=`     | `var &= expr`                                    | Bitwise AND and assignment               | `BitAndAssign` |
| `&&`     | `expr && expr`                                   | Short-circuiting logical AND             |                |
| `*`      | `expr * expr`                                    | Arithmetic multiplication                | `Mul`          |
| `*=`     | `var *= expr`                                    | Arithmetic multiplication and assignment | `MulAssign`    |
| `*`      | `*expr`                                          | Dereference                              |                |
| `*`      | `*const type`, `*mut type`                       | Raw pointer                              |                |
| `+`      | `trait + trait`, `'a + trait`                    | Compound type constraint                 |                |
| `+`      | `expr + expr`                                    | Arithmetic addition                      | `Add`          |
| `+=`     | `var += expr`                                    | Arithmetic addition and assignment       | `AddAssign`    |
| `,`      | `expr, expr`                                     | Argument and element separator           |                |
| `-`      | `- expr`                                         | Arithmetic negation                      | `Neg`          |
| `-`      | `expr - expr`                                    | Arithmetic subtraction                   | `Sub`          |
| `-=`     | `var -= expr`                                    | Arithmetic subtraction and assignment    | `SubAssign`    |
| `->`     | `fn(...) -> type`, `|...| -> type`               | Function and closure return type         |                |
| `.`      | `expr.ident`                                     | Member access                            |                |
| `..`     | `..`, `expr..`, `..expr`, `expr..expr`           | Right-exclusive range literal            |                |
| `..=`    | `..=expr`, `expr..=expr`                         | Right-inclusive range literal            |                |
| `..`     | `..expr`                                         | Struct literal update syntax             |                |
| `..`     | `variant(x, ..)`, `struct_type { x, .. }`        | “And the rest” pattern binding           |                |
| `...`    | `expr...expr`                                    | In a pattern: inclusive range pattern    |                |
| `/`      | `expr / expr`                                    | Arithmetic division                      | `Div`          |
| `/=`     | `var /= expr`                                    | Arithmetic division and assignment       | `DivAssign`    |
| `:`      | `pat: type`, `ident: type`                       | Constraints                              |                |
| `:`      | `ident: expr`                                    | Struct field initializer                 |                |
| `:`      | `'a: loop {...}`                                 | Loop label                               |                |
| `;`      | `expr;`                                          | Statement and item terminator            |                |
| `;`      | `[...; len]`                                     | Part of fixed-size array syntax          |                |
| `<<`     | `expr << expr`                                   | Left-shift                               | `Shl`          |
| `<<=`    | `var <<= expr`                                   | Left-shift and assignment                | `ShlAssign`    |
| `<`      | `expr < expr`                                    | Less than comparison                     | `PartialOrd`   |
| `<=`     | `expr <= expr`                                   | Less than or equal to comparison         | `PartialOrd`   |
| `=`      | `var = expr`, `ident = type`                     | Assignment/equivalence                   |                |
| `==`     | `expr == expr`                                   | Equality comparison                      | `PartialEq`    |
| `=>`     | `pat => expr`                                    | Part of match arm syntax                 |                |
| `>`      | `expr > expr`                                    | Greater than comparison                  | `PartialOrd`   |
| `>=`     | `expr >= expr`                                   | Greater than or equal to comparison      | `PartialOrd`   |
| `>>`     | `expr >> expr`                                   | Right-shift                              | `Shr`          |
| `>>=`    | `var >>= expr`                                   | Right-shift and assignment               | `ShrAssign`    |
| `@`      | `ident @ pat`                                    | Pattern binding                          |                |
| `^`      | `expr ^ expr`                                    | Bitwise exclusive OR                     | `BitXor`       |
| `^=`     | `var ^= expr`                                    | Bitwise exclusive OR and assignment      | `BitXorAssign` |
| `|`      | `pat | pat`                                      | Pattern alternatives                     |                |
| `|`      | `expr | expr`                                    | Bitwise OR                               | `BitOr`        |
| `|=`     | `var |= expr`                                    | Bitwise OR and assignment                | `BitOrAssign`  |
| `||`     | `expr || expr`                                   | Short-circuiting logical OR              |                |
| `?`      | `expr?`                                          | Error propagation                        |                |

### [Non-operator Symbols](https://doc.rust-lang.org/book/appendix-02-operators.html#non-operator-symbols)

The following list contains all non-letters that don’t function as operators; that is, they don’t behave like a function or method call.

Table B-2 shows symbols that appear on their own and are valid in a variety of locations.

Table B-2: Stand-Alone Syntax

| Symbol                                        | Explanation                                                  |
| --------------------------------------------- | ------------------------------------------------------------ |
| `'ident`                                      | Named lifetime or loop label                                 |
| `...u8`, `...i32`, `...f64`, `...usize`, etc. | Numeric literal of specific type                             |
| `"..."`                                       | String literal                                               |
| `r"..."`, `r#"..."#`, `r##"..."##`, etc.      | Raw string literal, escape characters not processed          |
| `b"..."`                                      | Byte string literal; constructs a `[u8]` instead of a string |
| `br"..."`, `br#"..."#`, `br##"..."##`, etc.   | Raw byte string literal, combination of raw and byte string literal |
| `'...'`                                       | Character literal                                            |
| `b'...'`                                      | ASCII byte literal                                           |
| `|...| expr`                                  | Closure                                                      |
| `!`                                           | Always empty bottom type for diverging functions             |
| `_`                                           | “Ignored” pattern binding; also used to make integer literals readable |

Table B-3 shows symbols that appear in the context of a path through the module hierarchy to an item.

Table B-3: Path-Related Syntax

| Symbol                                  | Explanation                                                  |
| --------------------------------------- | ------------------------------------------------------------ |
| `ident::ident`                          | Namespace path                                               |
| `::path`                                | Path relative to the crate root (i.e., an explicitly absolute path) |
| `self::path`                            | Path relative to the current module (i.e., an explicitly relative path). |
| `super::path`                           | Path relative to the parent of the current module            |
| `type::ident`, `<type as trait>::ident` | Associated constants, functions, and types                   |
| `<type>::...`                           | Associated item for a type that cannot be directly named (e.g., `<&T>::...`, `<[T]>::...`, etc.) |
| `trait::method(...)`                    | Disambiguating a method call by naming the trait that defines it |
| `type::method(...)`                     | Disambiguating a method call by naming the type for which it’s defined |
| `<type as trait>::method(...)`          | Disambiguating a method call by naming the trait and type    |

Table B-4 shows symbols that appear in the context of using generic type parameters.

Table B-4: Generics

| Symbol                         | Explanation                                                  |
| ------------------------------ | ------------------------------------------------------------ |
| `path<...>`                    | Specifies parameters to generic type in a type (e.g., `Vec<u8>`) |
| `path::<...>`, `method::<...>` | Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., `"42".parse::<i32>()`) |
| `fn ident<...> ...`            | Define generic function                                      |
| `struct ident<...> ...`        | Define generic structure                                     |
| `enum ident<...> ...`          | Define generic enumeration                                   |
| `impl<...> ...`                | Define generic implementation                                |
| `for<...> type`                | Higher-ranked lifetime bounds                                |
| `type<ident=type>`             | A generic type where one or more associated types have specific assignments (e.g., `Iterator<Item=T>`) |

Table B-5 shows symbols that appear in the context of constraining generic type parameters with trait bounds.

Table B-5: Trait Bound Constraints

| Symbol                        | Explanation                                                  |
| ----------------------------- | ------------------------------------------------------------ |
| `T: U`                        | Generic parameter `T` constrained to types that implement `U` |
| `T: 'a`                       | Generic type `T` must outlive lifetime `'a` (meaning the type cannot transitively contain any references with lifetimes shorter than `'a`) |
| `T : 'static`                 | Generic type `T` contains no borrowed references other than `'static` ones |
| `'b: 'a`                      | Generic lifetime `'b` must outlive lifetime `'a`             |
| `T: ?Sized`                   | Allow generic type parameter to be a dynamically sized type  |
| `'a + trait`, `trait + trait` | Compound type constraint                                     |

Table B-6 shows symbols that appear in the context of calling or defining macros and specifying attributes on an item.

Table B-6: Macros and Attributes

| Symbol                                      | Explanation        |
| ------------------------------------------- | ------------------ |
| `#[meta]`                                   | Outer attribute    |
| `#![meta]`                                  | Inner attribute    |
| `$ident`                                    | Macro substitution |
| `$ident:kind`                               | Macro capture      |
| `$(…)…`                                     | Macro repetition   |
| `ident!(...)`, `ident!{...}`, `ident![...]` | Macro invocation   |

Table B-7 shows symbols that create comments.

Table B-7: Comments

| Symbol     | Explanation             |
| ---------- | ----------------------- |
| `//`       | Line comment            |
| `//!`      | Inner line doc comment  |
| `///`      | Outer line doc comment  |
| `/*...*/`  | Block comment           |
| `/*!...*/` | Inner block doc comment |
| `/**...*/` | Outer block doc comment |

Table B-8 shows symbols that appear in the context of using tuples.

Table B-8: Tuples

| Symbol                   | Explanation                                                  |
| ------------------------ | ------------------------------------------------------------ |
| `()`                     | Empty tuple (aka unit), both literal and type                |
| `(expr)`                 | Parenthesized expression                                     |
| `(expr,)`                | Single-element tuple expression                              |
| `(type,)`                | Single-element tuple type                                    |
| `(expr, ...)`            | Tuple expression                                             |
| `(type, ...)`            | Tuple type                                                   |
| `expr(expr, ...)`        | Function call expression; also used to initialize tuple `struct`s and tuple `enum` variants |
| `expr.0`, `expr.1`, etc. | Tuple indexing                                               |

Table B-9 shows the contexts in which curly braces are used.

Table B-9: Curly Brackets

| Context      | Explanation      |
| ------------ | ---------------- |
| `{...}`      | Block expression |
| `Type {...}` | `struct` literal |

Table B-10 shows the contexts in which square brackets are used.

Table B-10: Square Brackets

| Context                                            | Explanation                                                  |
| -------------------------------------------------- | ------------------------------------------------------------ |
| `[...]`                                            | Array literal                                                |
| `[expr; len]`                                      | Array literal containing `len` copies of `expr`              |
| `[type; len]`                                      | Array type containing `len` instances of `type`              |
| `expr[expr]`                                       | Collection indexing. Overloadable (`Index`, `IndexMut`)      |
| `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | Collection indexing pretending to be collection slicing, using `Range`, `RangeFrom`, `RangeTo`, or `RangeFull` as the “index” |